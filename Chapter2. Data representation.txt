	NUMBER SYSTEMS
	* An unsigned integer with n digits in q-base system is represented in general formular:

		x(n-1)...x(1)x(0) = x(n - 1).q^(n - 1) + ... + x(1).q(1) + x(0).q(0)

	-> The base system commonly represented in the computer is base 2.

	
	UNSIGNED INTEGERS REPRESENTATION
	* Represent positive values such as length, weight, ASCII code, color code, ...
	
	* The values of an unsigned integer is the magnitude of its underlying binary pattern

	Ex: n = 8, The binary representation 10000001(2)
	Absolute value is 10000001(2) -> 129(10)
	Hence, the integer is 129(10).

	* The n-bits binary pattern can represent the value from 0 - (2^n - 1)

	
	SIGNED INTEGERS REPRESENTATION
	* Can represent zero, positive integers, as well as negative integers.
	
	* Four representation schemes are available for signed integers:
	- Sign-Magnitude representation.
	
	- 1's complement representation.

	- 2's complement representation.

	- Biased (k - excess).

	-> Signed numbers in the computer system are represented in the 2's complement scheme.


	Sign-Magnitude representation:
	* The most significant bit (MSB) is the sign bit:
	- 0 -> positive integer
	- 1 -> negative integer

	* The remaining (n - 1) bits represents the magnitude (absolute value) of the integer.

	Ex: Suppose that n = 8, the binary representation 10000001
	Sign bit is 1 -> negative integer
	Absolute value is 0000001(2) -> 1(10)
	Hence, the integer is -1(10).

	* The n-bits pattern can represent the values from (-2^(n - 1) + 1) to (2^(n - 1) - 1).
	
	* Positive number and negative number differ MSB value (sign bit), the absolute value are 
	the same.

	* There are two representations for the number zero, which could lead to inefficiency and 
	confusion.


	One's Complement representation:
	* The most significant bit (MSB) is the sign bit:
	- 0 -> positive integer
	- 1 -> negative integer

	* The remaining (n - 1) bits represents the magnitude of the integer (n is the length of 
	bit pattern) as follow:
	- Positive integers: The absolute value of the integer is equal to the magnitude of the 
	(n - 1)-bit binary pattern.
	- Negative integers: The absolute value of the integer is equal to the magnitude of the 
	complement(inverse) of the (n - 1)-bit binary pattern.

	Ex: Suppose that n = 8, the binary representation 10000001
	Sign bit is 1 -> negative number
	Absolute value is the complement of 0000001 -> 1111110 -> 126(10)
	Hence, the integer is -126(10)

	* The n-bits binary pattern can represent the values from (-2^(n - 1) + 1) to 	
	(2^(n - 1) - 1).

	* There are two representations for the number zero, which could lead to inefficiency and 
	confusion.

	* The positive integers and negative integers need to be processed separately.


	Two's Complement representation:
	* The most significant bit (MSB) is the sign bit:
	- 0 -> positive integer
	- 1 -> negative integer

	* The remaining (n - 1) bits represents the magnitude of the integer (n is the length of 
	bit pattern) as follow:
	- Positive integers: The absolute value of the integer is equal to the magnitude of the 
	(n - 1)-bit binary pattern.
	- Negative integers: The absolute value of the integer is equal to the magnitude of the 
	complement(inverse) of the (n - 1)-bit binary pattern plus one.

	Ex: Suppose that n = 8, the binary representation 10000001
	Sign bit is 1 -> Negative number
	Absolute value is the complement of 0000001 + 1 -> 1111110 + 1 -> 1111111(2) -> 127(10)
	Hence, the integer is -127(10)

	* Can represent the values from (-2(n - 1) + 1) to (2^(n - 1) - 1).
	
	* There is one representation for the number zero.

	* The two's complement number of N is the negative form of N

	Ex: How to represent -5(10) in binary:
	The bit pattern of 5 is 0101
	The two's complement number of 5 is 1011
	Hence, the binary pattern that represent -5 is 1011


	Biased (K - excess):
	* Choose K (a positive integer) to allows operations on the biased numbers to be the same 
	as for unsigned integers but represents both positive and negative values. K is usually
	(2^(n - 1) - 1) or (2^(n - 1)).

	* The most significant bit (MSB) is the sign bit:
	- 1 -> Positive integer
	- 0 -> Negative integer

	* All n bits represents the magnitude of the integer by subtraction between the bias value 
	K and unsigned value N of that n-bits binary pattern
	- Positive integer: N > K, the absolute value of the integer is equal to N - K.
	- Negative integer: N < K, the absolute value of the integer is equal to K - N.

	Ex: Suppose that n = 8, K = 127, the binary representation of N is 10000001 with unsigned 
	value is 129(10)
	N is positive integer.
	Absolute value is N - K = 129 - 127 = 2(10)
	Hence, the integer is 2(10).

	* The n-bits binary pattern with K = 2^(n - 1) - 1 can represent the values from -K to
	2^n - K - 1.

	* There is one representation for the number zero: 01111111.

	* Biased representations are now primarily used for the exponent of floating-point numbers.

	Ex: Suppose that n = 8, K = 127, how to represent a number in binary
	Positive number: 25(10)
	N = 25 + K = 25 + 127 = 152
	-> The bit binary pattern is 10011000

	Negative number: -25(10)
	N = -25 + K = -25 + 127 = 102
	-> The bit binary pattern is 01100110

	
	INTEGER OPERATIONS
	* Logical operations (AND, OR, XOR, NOT, SHL, SHR, SAR, ROR, ROL).
	- AND: Only right when two binary digit right together.
	
	- OR: Only wrong when two binary digit wrong together.

	- XOR: Only right when two binary digit not the same.

	- NOT: Inverse of digit.

	- SHL (Shift left logical): Shift all digits from (n - 1) to (1) to left and remove the last digit.

	- SHR (Shift right logical): Shift all digits from (n) to (2) to right and remove the first digit.

	- SAR (Shift right arithmetic): Shift all digits from (n - 1) to (1) to left and the first digit is keep up.

	- ROR (Rotate right): Shift all digits from (n) to (2) to right and bring (1) to the first place.

	- ROL (Rotate left): Shift all digits from (n - 1) to (1) to left and bring (n) to the last place.
	
		- Applications:
		+ x SHL y = x . 2^y

		+ x SAR y = x / 2^y

		+ AND uses to switch off a bit
		  Convert lower case to upper case

		+ OR uses to switch on a bit
		  Convert upper case to lower case

		+ XOR, NOT uses to reverse a bit

		+ x XOR x = 0

		+ Get the value of bit i: (x SHR i) AND 1
	
		+ Set the value 1's of bit i: (1 SHL i) OR x

		+ Set the value 0's of bit i: NOT(1 SHL i) AND x
		
		+ Reverse bit i: (1 SHL i) XOR x

	* Arithmetic operations (add, subtract, multiply, division).


	FIXED POINT NUMBERS
	* 1 bit for sign bit, n bits for integer part and m bits for fraction part.

	* Range for integer part:
	- Unsigned integer: [0, 2(n) - 1].

	- Signed integer: [-2^(n - 1), 2^(n - 1) - 1].

	* Range for fraction part: [0, 1 - 2(-m)].

	-> Limited range of values can be represented, it does not allow enough numbers
	and accuracy.

	FLOATING POINT NUMBERS

	* Range: 
	- Single precision: [-(2 - 2^(-23)) x 2^127; -2^(-126)] U [2^(-126); (2 - 2^(-23)) x 2^127]

	- Double precision: [-(2 - 2^(-52)) x 2^1023; -2^(-1022)] U [2^(-1022); (2 - 2^(-52)) x 2^1023]

	* Normalized:
	- Optimize memory and improve accuracy.
	
	- Express in the follow notation: +- F x 2^E
		Sign | Exponent | Significand

	- IEEE: V = (-1)^S x 1.F x 2^E
		+ Single precision: 1 | 8 | 23 (32 bits).

		+ Double precision: 1 | 11 | 52 (64 bits).

	- Sign: 0 -> Positive, 1 -> Negative.
	
	- Exponent: Saved in n-bits pattern. Represented in K-excess form with (2^(m - 1) - 1)
		+ Single precision: K = 127.

		+ Double precision: K = 1023.
	
	- Significand (Fraction): The remaining bits after dot sign.

	Ex: 5.375 -> 101.011
	-> Sign bit: 0
	-> Exponent = 127 + 2 = 129 = 1000 0001
	-> Significand = 01011...0000
	=> 0 | 1000 0001 | 01011...0000 -> 1.01011 x 2^2

	* Denormalized: (represent very small value that cannot represent as normalized form)
	- IEEE: (-1)^S x 0.F x 2^E
	
	Ex: 0 00000000 10110000000000000000000 -> Denormalized
	Sign: 0 -> Positive
	E = 1 - 127 = -126
	M = 0.1011
	=> 0.1011 * 2^(-126) = 1011 * 2^(-130) = 11 * 2^(-130)

	Ex: 10 * 2^(125)
	-> 1010 * 2^(125) = 1.01 * 2^(128) -> inf
	=> 0 11111111 00000000000000000000000

	Ex: 20 * 2^120
	-> 10100 * 2^(120) = 1.01 * 2^(124)
	=> 0 11111011 01000000000000000000000
	
	Ex: 20 * 2^(-130)
	-> 10100 * 2^(-130) = 1.01 * 2^(-126)
	=> 0 00000001 01000000000000000000000
	
	Ex: 20 * 2^(-150)
	-> 10100 * 2^(-150) = 10010 * 2^(-24) * 2^(-126)
			    = 0.0000000000000000000101 * 2^(-126)
	=> 0 00000001 00000000000000000001010

	* +0: 0 | 0000 0000 | 00000...00000

	* -0: 1 | 0000 0000 | 00000...00000

	* inf: 0 | 1111 1111 | 0000...00000

	* -inf: 1 | 1111 1111 | 0000...0000

	* +NaN: 0 | 1111 1111 | 10000...000

	* -NaN: 1 | 1111 1111 | 10000...000
